---
title: "Stat 706 Final Project: Investigating Predictors of Movie Profitability"
subtitle: Nickhil Sethi
output:
  pdf_document: default
  word_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(ggplot2)
```
# TODO
- Finish data transformation, sample data
- Run plots of relevant variables against revenue. covariance matrix of genres.
- Run regression using step function AIC information criterion. Identify meaningful values using  p-values.
- Discuss the results. Run diagnostics, were the assumptions of LR correct?
- Prediction intervals

# Introduction
Profitability has become a contentious subject in the Film industry in recent years. The highest grossing films are typically either remakes of one kind or another (e.g. Marvel, Star Wars), or very small-budget independent films that receive high critical praise (e.g. Moonlight, Birdman, etc.). Acclaimed director G. Inarritu compared the issue to the polarization of the global economy, vis a vis the "99% and the 1%" (https://youtu.be/SQ7qKKQrSBY).

The goal of this paper is to investigate predictors of profitability, defined as `revenue - budget` (note, we assume films use all of their budget -- no more, no less). In particular, we consider the following variables:

- Release date. This allows us capture some kind of time-trend in profitability
- Budget. This captures the constraint that movies must be generally profitable. 
- Genre. This captures popularity effects by genre.
- Rating. This captures the "quality" of the film.

The dataset used here is Kaggle's "The Movies Dataset", located here https://www.kaggle.com/rounakbanik/the-movies-dataset. The dataset is an aggregate of data from GroupLens and TMDB.

# Methods

## Data
The two relevant tables and columns from the Movies dataset are `movies_metadata.csv` and `ratings.csv`, which have the following schemas, respectively:

```
MOVIES_METADATA {
  categories: [{ int: str }],
  revenue: float,
  budged: float,
  movieId: int
}

RATINGS {
  movieId: int,
  userId: int,
  rating: float,
}
```

Significant data transformation was needed to turn the Movies data into a usable format. First, the genre column of movies_metadata.csv is JSON, encoded as a list of pairs e.g. `{[genreId: genreName] ...}`. I obtained the set of unique genres named in the dataset, and added one boolean column for every genre found. Second, the `ratings` table contains movie ratings at the level of `(movieId, userId)` pairs; a groupby operation was performed to extract the average rating for each movie. 
Finally, a join was performed between the two tables using the join table `links.csv`.

Given the computationally expensive nature of the above transformations and the need to be able to "start fresh" i.e. recover from potential data corruption, I conducted the data transformation and resampling on AWS servers. See terraform code in this repository which sets up a postgresql database and a single server on AWS to store and manipulate this data.

`jsonb_array_elements` https://www.postgresql.org/docs/current/functions-json.html

## Model
