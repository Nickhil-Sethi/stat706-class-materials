---
title: "Stat 706 Final Project: Investigating Predictors of Movie Profitability"
subtitle: Nickhil Sethi
output:
  pdf_document: default
  word_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(ggplot2)
library(dplyr)
library(gridExtra)
library(printr)
library(faraway)

# global variable, don't want to echo this
GENRE_COLUMNS <- c( "genre_thriller", "genre_war", "genre_fantasy", "genre_documentary", "genre_gohands", "genre_action", "genre_family", "genre_crime", "genre_comedy", "genre_foreign", "genre_adventure", "genre_mystery", "genre_science_fiction", "genre_horror", "genre_drama", "genre_animation", "genre_romance", "genre_western", "genre_history", "genre_tv_movie", "genre_music")

CSV_FILE_PATH <-  "/Users/nickhilsethi/src/stat706-class-materials/final-project/terraform/project-infra/project_data.csv"

```
# TODO
- Run plots of relevant variables against revenue. covariance matrix of genres.
- Run regression using step function AIC information criterion. Identify meaningful values using  p-values.
- Discuss the results. Run diagnostics, were the assumptions of LR correct?
- Prediction intervals

# Introduction
The goal of this paper is to determine factors which predict a film's profitability in Kaggle's ["The Movies Dataset"](https://www.kaggle.com/rounakbanik/the-movies-dataset), an aggregate of data from GroupLens and TMDB containing data on film revenue, budget, genre, and ratings. In particular, we hope to determine how critical reception and budge affect profitability.

We begin from a complete set of predictors (see below) and use an iterative procedure to minimize the Akaike-Information Criterion (i.e. R's `step` function) in order to discover the most relevant variables. We then examine the reduced model for significant predictors, interpret the results, and construct prediction intervals for movies of varying characteristics.

The variables used at the outset are:

- Release date. This allows us capture some kind of time-trend in profitability
- Budget. This captures the constraint that movies must be generally profitable. 
- Genre. This captures popularity effects by genre.
- Rating. This captures the critical-reception of the film.

# Methods

## Data
The Movies dataset contains three tables relevant to our analysis -- `movies_metadata`, `ratings`, and a join table `links`. The three tables have the following schemas:

```
MOVIES_METADATA {
  genres: [{ genreId: <int>,  name: <str> }],
  revenue: float,
  budged: float,
  imdbId: int
}

RATINGS {
  movieId: int,
  userId: int,
  rating: float,
}

LINKS {
  movieId: int,
  imdbId: int
}
```
### Data Transformation and Cleaning

Some preparation was needed to turn these three tables into a usable format. The genre column of `movies_metadata` is JSON, encoded as a list of pairs representing the set of genres the film is associated with e.g. `[{genreId: 1, genreName: Action}, {genreId: 2, genreName: Comedy}]`; this column was converted to a set of boolean columns e.g. `genre_action` with `True` representing that the film belongs to that genre.

The `ratings` table contains movie ratings at the level of `(movieId, userId)` pairs, i.e. at the level of an individual critic's review; a grouping operation was performed to compute the average rating for each movie. Finally, a join was performed between the two tables using the join table `links` to create a single `movies` table, which serves as the final dataset on which we run our regression.

The `movies` schema is described below. The `profit` column is a derived quantity defined as `revenue - budget`; note the assumption here that all films use exactly there budget. The table also contains 32 genre columns with naming pattern `genre_[name]`; the prefix of "genre_" helps to avoid unfortunate name conflicts with keywords in postgres and python e.g. foreign (as in foreign key).

```
movies {
  imdb_id: int,
  revenue: float,
  budget: float,
  profit: float,
  release_date: date,
  average_rating: float,
  genre_action: boolean,
  genre_thriller: boolean,
  ...
  genre_music: boolean
}
```

Finally, rows with missing values are dropped. As can be seen from the chart below, the variable `is_complete` may be correlated with revenue, with incomplete rows typically having `0` profit, but this is not a major conceptual issue for the project for two reasons; first, the vast majority of the films in the dataset are roughly break even.


```{r}
movies <- read.csv(file = CSV_FILE_PATH, header = TRUE, sep = ",")

# compute profits for each film
movies$profit <- movies$revenue - movies$budget

# cast the release_date field to a date type
movies$release_date <- as.Date(movies$release_date)

# cast genre columns to boolean
for (col in GENRE_COLUMNS) {
  movies[col] <- lapply(movies[col], as.logical)
}

# now just restrict to the columns we need
features <- c(c("profit", "budget", "release_date", "average_rating"), GENRE_COLUMNS)

movies <- movies[, features]

movies$is_complete <- complete.cases(movies)

p1 <- ggplot(
  movies, aes(x=is_complete, y=profit)) + geom_jitter(width = .05, height=.05) + geom_point()
p2 <- ggplot(
  movies, aes(x=is_complete)) + geom_histogram(stat="count")
grid.arrange(p1, p2, nrow=1)

# now we drop the incomplete cases
movies <- movies[movies$is_complete == TRUE, ]

# subsample 20% of the data
# movies <- movies[sample(nrow(movies), nrow(movies) / 2), ]
```


### General Characteristics and Distribution

Some informative plots on the relevant variables are shown below -- the distributions of `profit`, `release_date` and `average_rating` ("average" here refers to average over critics for each film). All three seem approximately normal `profit` is heavily peaked at zero, with some

```{r}
p1 <- ggplot(movies, aes(x=profit)) + geom_histogram(bins=40)
p2 <- ggplot(movies, aes(x=average_rating)) + geom_histogram(bins = 25)
p3 <- ggplot(movies, aes(x=release_date)) + geom_histogram(bins = 25)
grid.arrange(p1, p2, p3, nrow=2)
```
```{r}
p2 <- ggplot(movies, aes(x=budget, y=profit)) + geom_point()
p3 <- ggplot(movies, aes(x=release_date, y=profit)) + geom_point()
p1 <- ggplot(movies, aes(x=average_rating, y=profit)) + geom_point()
grid.arrange(p1, p2, p3, nrow=2)
```
Budget is positively correlated with profit, with the relationship being heteroskedastic.Ratings appear to have some effect on profitability, but as we can clearly see the relationship is non-linear. Release date has an interesting relationship with profit.

## Model

```{r}
lmod <- lm(profit ~ ., data = movies)
lmod_reduced <- step(lmod, trace=0)

sumary(lmod)
sumary(lmod_reduced)
```


# Discussion


## Challenges
Not robust to re-sampling. Co-linearity between variables makes it difficult to interpret for causality.
